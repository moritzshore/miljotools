#' Download SeNorge2018 data
#'
#' This function downloads the files as queried by `metnordic_buildquery()`. If
#' you do not pass a `directory`, files will be downloaded in the working
#' directory. You have the option of downloading the following SeNorge2018
#' variables at daily resolution:
#' - `tn` (minimum daily temperature in Celsius)
#' - `tx` (maximum daily temperature in Celsius)
#' - `rr` (sum daily precipitation in mm),
#' - `tg` (mean daily temperature in Celsius)
#' If you do not provide a vector of variables to download, all will be downloaded.
#' You can also provide a `polygon` (Georeferenced simple feature, the same that
#' you provided to `metnordic_coordwindow()`) to verify that the download is
#' covering your desired area.
#' @param queries (list) generated by metnordic_buildqueries()
#' @param directory (char) folder where to download (will be created if it does not exist)
#' @param variables (char, vector) variables to download ("tn", "tx", "rr", "tg")
#' @param polygon (char) path to same polygon shapefile as passed to `metnordic_coordwindow()`
#' @param verbose (flag) print status?
#'
#' @returns path to downloaded files
#' @export
#'
senorge_download <- function(queries, directory = NULL, variables = NULL, polygon = NULL, verbose = FALSE){
  if(directory %>% is.null()){directory = getwd()}
  if(variables %>% is.null()){variables = c("tn", "tx", "rr", "tg")}
  dir.create(directory, recursive = T, showWarnings = F)
  list.files(directory, full.names = T) -> existing_files
  if(length(existing_files) > 0 ){
    file.remove(existing_files) -> rem_res
  }
  for (i in seq_along(queries$filenames)) {
    mt_print(verbose, "senorge_download", text = "Downloading:", queries$filenames[i])
    nc_filepath <- paste0(directory, "/", queries$filenames[i])
    ncin <- nc_open(queries$full_urls[i])
    all_vars <- ncin$var %>% names()
    nc_create(filename = nc_filepath, vars = ncin$var, force_v4 = F) -> newnc
    diagnostics = T
    for (variable in all_vars) {
      mt_print(verbose, "senorge_download", text = "Downloading..", variable, rflag = T)
      if(verbose){cat("                                                                               \r")}
      mt_print(diagnostics, "senorge_download", text = "Getting data for:", variable, rflag = T)
      # getting and applying values for current variable
      values <- ncvar_get(nc = ncin, varid = variable)
      ncvar_put(nc = newnc, varid = variable, vals = values)

      # adding each attribute
      mt_print(diagnostics, "senorge_download", text = "Applying attributes for", variable, rflag = T)
      attrs <- ncatt_get(nc = ncin, varid = variable)
      all_attrs <- attrs %>% names()
      for (attribute in all_attrs) {
        mt_print(diagnostics, "senorge_download", text = "Adding attribute:", paste0(variable, "[", attribute,"]"), rflag = T)
        attr_val <- attrs[[attribute]]
        ncatt_put(nc = newnc, varid = variable, attname = attribute, attval = attr_val)
        if(verbose){cat("\r")}
      }
      all_glob_attr <- ncatt_get(ncin, varid = 0)
      glob_attr_names <- all_glob_attr %>% names()
      for (glob_attr in glob_attr_names) {
        current_glob_attr <- all_glob_attr[[glob_attr]]
        mt_print(diagnostics, "senorge_download", text = "Applying global attribures:", text2 = glob_attr, rflag = T)
        ncatt_put(nc = newnc, varid = 0, attname = glob_attr, attval = current_glob_attr)

      }
    }
    nc_close(ncin)
    nc_close(newnc)
    mt_print(verbose, "senorge_download", text = "Finished Download                                                                   ",
             rflag = T)
    if(verbose){cat("\r\n")}
    # if a polygon simple feature is provided, then preview.
    if(polygon %>% is.null() == FALSE){
      terra::rast(nc_filepath, variables[1])[[1]] -> myrast
      title = paste(terra::longnames(x =myrast))
      subtitle = paste0(terra::sources(myrast), "\n", terra::time(myrast) %>% as.Date())
      ggplot2::ggplot() +
        tidyterra::geom_spatraster(data = myrast, interpolate = F)+
        ggplot2::geom_sf(data = polygon, color = "red", fill = NA, size = 2)+
        ggplot2::theme_bw()+
        ggplot2::ggtitle(title, subtitle)+
        ggplot2::guides(fill=ggplot2::guide_legend(title=terra::units(myrast))) -> myggplot
      print(myggplot)
    }
  }
  return(directory)
}
#
#


# Testing parameter set
# if(FALSE){
#   directory <- "../mt-testing/senorge/download_indiv_test2"
#   outdir <- "../mt-testing/senorge/extract"
#   area = "../swat-cs10/model_data/input/shape/cs10_basin.shp" %>% sf::read_sf()
#   variables <- c("tg", "tx", "tn", "rr")
#   buffer = 1000
#   verbose = T
#   senorge_extract_grid(directory,outdir, area, variables, buffer, verbose)
# }



#' Extract data from SeNorge2018 files
#'
#' WIP
#'
#' @param directory WIP
#' @param outdir WIP
#' @param area WIP
#' @param variables WIP
#' @param buffer WIP
#' @param verbose WIP
#'
#' @returns WIP
#' @export
#'
#' @examples
#'
#' WIP
senorge_extract_grid <- function(directory,outdir, area, variables, buffer, verbose){
  directory %>% list.files(full.names = T) -> filenames # move this into second function
  get_overlapping_cells(
    directory = directory,
    variables = variables,
    area = area,
    buffer = buffer,
    verbose = verbose
  ) %>% senorge_nc_to_df(directory = directory,
                         filenames = filenames,
                         verbose = verbose) %>%
    write_senorge(outdir = outdir, verbose = verbose)
  mt_print(verbose, "senorge_extract_grid", "Finished, files can be found here:", outdir)
  return(outdir)
}

# Returns data in tidy format from a grid.
senorge_nc_to_df <- function(grid, directory, filenames, verbose) {
  grid$geometry %>% length() -> station_nr
  filenames %>% stringr::str_split("_", simplify = T) -> splitted
  splitted[,ncol(splitted)] %>% stringr::str_remove_all(".nc") -> years
  extract_senorge_variable <- function(variable){

    extract_senorge_year <- function(year){
      # Grab the right file
      filepath <- list.files(directory,
                             pattern = paste0("seNorge2018_", year, ".nc"),
                             full.names = T)
      if(length(filepath) == 0){
        stop("File `", paste0(directory, "/seNorge2018_", year, ".nc"), "` not found!")
      }
      varrast <- terra::rast(filepath, variable)
      terra::time(varrast) %>% as.Date() -> timelist
      grid <- grid %>% sf::st_transform(sf::st_crs(varrast))
      datamatrix <- terra::extract(varrast, grid, method = "simple", bind = T)
      cell_to_df <- function(cell){
        mt_print(verbose, "senorge_extract_grid", paste0("Extracting ", variable, " [", year, "]"), paste0("[", cell, "/", station_nr, "]" ), rflag = T)
        if(verbose){cat("                                                                 \r")}
        datamatrix[cell] %>% as.data.frame() %>% t() %>% as.data.frame(row.names = F) -> mydf
        return_df <- tibble::tibble(date = timelist, value = mydf$V1, grid_cell = cell, variable = variable)
        return(return_df)
      }
      lapply(c(1:station_nr),FUN =cell_to_df) %>% do.call(what = "rbind") -> variable_full
      return(variable_full)
    }

    lapply(X = years, FUN = extract_senorge_year) -> one_var_year_list
    one_var_year_list %>% do.call(what = "rbind", args = .) -> one_var_all_year_df
    return(one_var_all_year_df)
  }
  mt_print(verbose, "senorge_extract_grid", "Extracting data from the following year(s):", paste0(years, collapse = ", "))
  lapply(X = variables, FUN = extract_senorge_variable) -> list_all_vars
  list_all_vars %>% do.call(what = "rbind") -> megadf
}

# writes files
write_senorge <- function(megadf, outdir, verbose){
  cells <- megadf %>% pull(grid_cell) %>% unique() %>% sort()
  dir.create(outdir, showWarnings = F)
  warning("problem with leap years here, probably needs to be fixed in query buildr")
  for (cell in cells) {
    mt_print(verbose, "senorge_extract_grid", "Writing cells to file..", paste0("[", cell, "/",  length(cells), "]"), rflag = T)
    if(verbose){cat("                                                                 \r")}
    megadf %>% filter(grid_cell ==  cell) %>%
      rename(vstation = grid_cell) %>%
      pivot_wider(values_from = value, names_from = variable, id_cols = c(vstation, date)) -> vstatslice
    filename <- paste0(outdir, "/", "senorge_vstation_", cell, ".csv")
    readr::write_csv(x = vstatslice, file = filename)
  }
}
